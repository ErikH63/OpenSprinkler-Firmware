diff --git a/OpenSprinkler.cpp b/OpenSprinkler.cpp
index fe064aa..408f1e4 100644
--- a/OpenSprinkler.cpp
+++ b/OpenSprinkler.cpp
@@ -26,6 +26,12 @@
 #include "gpio.h"
 #include "testmode.h"
 
+//
+// when setting/clearing a station state force the station HW
+// state instead of relying on the station_bits values.
+//
+#define STA_SET_FORCE   0x80
+
 /** Declare static data members */
 OSMqtt OpenSprinkler::mqtt;
 NVConData OpenSprinkler::nvdata;
@@ -1468,8 +1474,10 @@ void OpenSprinkler::switch_special_station(byte sid, byte value) {
 byte OpenSprinkler::set_station_bit(byte sid, byte value) {
 	byte *data = station_bits+(sid>>3);  // pointer to the station byte
 	byte mask = (byte)1<<(sid&0x07); // mask
-	if (value) {
-		if((*data)&mask) return 0;	// if bit is already set, return no change
+    byte force = value & STA_SET_FORCE;
+
+	if (value & 1) {
+		if( (*data)&mask && force == 0 ) return 0;	// if bit is already set, return no change
 		else {
 			(*data) = (*data) | mask;
 			engage_booster = true; // if bit is changing from 0 to 1, set engage_booster
@@ -1477,7 +1485,7 @@ byte OpenSprinkler::set_station_bit(byte sid, byte value) {
 			return 1;
 		}
 	} else {
-		if(!((*data)&mask)) return 0; // if bit is already reset, return no change
+		if( !((*data)&mask) && force == 0 ) return 0; // if bit is already reset, return no change
 		else {
 			(*data) = (*data) & (~mask);
 			if(hw_type == HW_TYPE_LATCH) {
@@ -1494,7 +1502,7 @@ byte OpenSprinkler::set_station_bit(byte sid, byte value) {
 void OpenSprinkler::clear_all_station_bits() {
 	byte sid;
 	for(sid=0;sid<=MAX_NUM_STATIONS;sid++) {
-		set_station_bit(sid, 0);
+		set_station_bit(sid, STA_SET_FORCE | 0);
 	}
 }
 
@@ -1577,7 +1585,9 @@ void OpenSprinkler::switch_rfstation(RFStationData *data, bool turnon) {
  * Third byte is either 0 or 1 for active low (GND) or high (+5V) relays
  */
 void OpenSprinkler::switch_gpiostation(GPIOStationData *data, bool turnon) {
-	byte gpio = (data->pin[0] - '0') * 10 + (data->pin[1] - '0');
+    byte gpio = 0;
+    for( int i = 0 ; i < sizeof(data->pin) ; i++ )
+        gpio = gpio * 10 + data->pin[i] - '0';
 	byte activeState = data->active - '0';
 
 	pinMode(gpio, OUTPUT);
diff --git a/OpenSprinkler.h b/OpenSprinkler.h
index fd4278a..366123a 100644
--- a/OpenSprinkler.h
+++ b/OpenSprinkler.h
@@ -105,7 +105,7 @@ struct RemoteStationData {
 
 /** GPIO station data structures - Must fit in STATION_SPECIAL_DATA_SIZE */
 struct GPIOStationData {
-	byte pin[2];
+	byte pin[3];
 	byte active;
 };
 
diff --git a/defines.h b/defines.h
index 6169fab..b8c1aad 100644
--- a/defines.h
+++ b/defines.h
@@ -363,6 +363,25 @@ enum {
 	#define V2_PIN_SENSOR1       3  // sensor 1
 	#define V2_PIN_SENSOR2       10 // sensor 2
 
+#elif defined(EMUL) // for OSPi but with emulated GPIOs, no SR, buttons, etc
+
+	#define OS_HW_VERSION    OSPI_HW_VERSION_BASE
+	#define PIN_SR_LATCH      -1    // shift register latch pin
+	#define PIN_SR_DATA       -1    // shift register data pin
+	#define PIN_SR_DATA_ALT   -1    // shift register data pin (alternative, for RPi 1 rev. 1 boards)
+	#define PIN_SR_CLOCK      -1    // shift register clock pin
+	#define PIN_SR_OE         -1    // shift register output enable pin
+	#define PIN_SENSOR1		  -1
+	#define PIN_SENSOR2		  -1
+	#define PIN_RFTX          -1    // RF transmitter pin
+	#define PIN_BUTTON_1      -1    // button 1
+	#define PIN_BUTTON_2      -1    // button 2
+	#define PIN_BUTTON_3      -1    // button 3
+
+	// #define PIN_FREE_LIST		{5,6,7,8,9,10,11,12,13,16,18,19,20,21,23,24,25,26}  // free GPIO pins
+	#define PIN_FREE_LIST		{}  // free GPIO pins
+	#define ETHER_BUFFER_SIZE   16384
+
 #elif defined(OSPI) // for OSPi
 
 	#define OS_HW_VERSION    OSPI_HW_VERSION_BASE
diff --git a/gpio.cpp b/gpio.cpp
index 80d1789..cf493c7 100644
--- a/gpio.cpp
+++ b/gpio.cpp
@@ -188,6 +188,9 @@ static byte GPIOExport(int pin) {
 	char buffer[BUFFER_MAX];
 	int fd, len;
 
+    if( pin < 0 )
+        return 0;
+
 	fd = open("/sys/class/gpio/export", O_WRONLY);
 	if (fd < 0) {
 		DEBUG_PRINTLN("failed to open export for writing");
@@ -241,6 +244,9 @@ void pinMode(int pin, byte mode) {
 	char path[BUFFER_MAX];
 	int fd;
 
+    if( pin < 0 )
+        return;
+
 	snprintf(path, BUFFER_MAX, "/sys/class/gpio/gpio%d/direction", pin);
 
 	struct stat st;
@@ -275,6 +281,9 @@ int gpio_fd_open(int pin, int mode) {
 	char path[BUFFER_MAX];
 	int fd;
 
+    if( pin < 0 )
+        return -1;
+
 	snprintf(path, BUFFER_MAX, "/sys/class/gpio/gpio%d/value", pin);
 	fd = open(path, mode);
 	if (fd < 0) {
@@ -293,6 +302,9 @@ void gpio_fd_close(int fd) {
 byte digitalRead(int pin) {
 	char value_str[3];
 
+    if( pin < 0 )
+        return -1;
+
 	int fd = gpio_fd_open(pin, O_RDONLY);
 	if (fd < 0) {
 		return 0;
@@ -318,7 +330,11 @@ void gpio_write(int fd, byte value) {
 
 /** Write digital value */
 void digitalWrite(int pin, byte value) {
-	int fd = gpio_fd_open(pin);
+	int fd;
+    if( pin < 0 )
+        return;
+
+	fd = gpio_fd_open(pin);
 	if (fd < 0) {
 		return;
 	}
diff --git a/server.cpp b/server.cpp
index 28d100a..68c310d 100644
--- a/server.cpp
+++ b/server.cpp
@@ -629,8 +629,11 @@ void server_change_stations() {
 			// only process GPIO and HTTP stations for OS 2.3, above, and OSPi
 			if(tmp_buffer[0] == STN_TYPE_GPIO) {
 				// check that pin does not clash with OSPi pins
-				byte gpio = (tmp_buffer[1] - '0') * 10 + tmp_buffer[2] - '0';
-				byte activeState = tmp_buffer[3] - '0';
+                GPIOStationData * std = (GPIOStationData *) (tmp_buffer + 1);
+				byte gpio = 0;
+				for( int i = 0 ; i < sizeof(std->pin) ; i++ )
+                    gpio = gpio * 10 + std->pin[i] - '0';
+				byte activeState = std->active - '0';
 
 				byte gpioList[] = PIN_FREE_LIST;
 				bool found = false;
@@ -650,7 +653,8 @@ void server_change_stations() {
 			}
 			// write spe data
 			file_write_block(STATIONS_FILENAME, tmp_buffer,
-				(uint32_t)sid*sizeof(StationData)+offsetof(StationData,type), STATION_SPECIAL_DATA_SIZE+1);
+				(uint32_t)sid*sizeof(StationData) + offsetof(StationData,type),
+                STATION_SPECIAL_DATA_SIZE+1);
 
 		} else {
 
